Œªapi_demo{
    // API Client Demonstration Application in Anarchy Inference
    // This application implements a robust API client with caching and rate limiting
    
    ∆ímain(){
        // Configuration
        œÉapiBaseUrl = "https://api.example.com";
        œÉcacheDir = "cache";
        ŒπrateLimit = 5;  // requests per second
        ŒπcacheExpiry = 3600;  // seconds (1 hour)
        
        ‚åΩ("Anarchy Inference API Client Demo");
        ‚åΩ("Base URL: " + apiBaseUrl);
        
        √∑{
            // Create cache directory if it doesn't exist
            Œπ(!?(cacheDir)){
                ‚åΩ("Creating cache directory: " + cacheDir);
                !("mkdir -p " + cacheDir);
            }
            
            // Initialize API client
            Œæclient = createApiClient(apiBaseUrl, rateLimit, cacheDir, cacheExpiry);
            
            // Example endpoints to fetch
            Œæendpoints = [
                "/users/1",
                "/users/2",
                "/posts?userId=1",
                "/comments?postId=1",
                "/albums?userId=1"
            ];
            
            // Process each endpoint
            Œæresults = ‚àÖ;
            
            ‚àÄ(endpoints, œÜ(endpoint){
                ‚åΩ("\nFetching: " + endpoint);
                
                // Make the API request with caching and rate limiting
                Œæresponse = client.get(endpoint);
                
                Œπ(response.success){
                    ‚åΩ("Success! Received " + üî§(‚éã.stringify(response.data).length) + " bytes");
                    ‚åΩ("Cache status: " + (response.fromCache ? "HIT" : "MISS"));
                    
                    // Add to results
                    results[endpoint] = {
                        "data": response.data,
                        "fromCache": response.fromCache,
                        "timestamp": response.timestamp
                    };
                }Œµ{
                    ‚åΩ("Error: " + response.error);
                }
            });
            
            // Demonstrate parallel requests
            ‚åΩ("\nDemonstrating parallel requests...");
            ŒæparallelEndpoints = [
                "/todos?userId=1",
                "/todos?userId=2",
                "/todos?userId=3"
            ];
            
            ŒæparallelResults = client.getParallel(parallelEndpoints);
            
            ‚åΩ("Completed " + üî§(parallelResults.length) + " parallel requests");
            ‚àÄ(parallelResults, œÜ(result, i){
                ‚åΩ("  " + parallelEndpoints[i] + ": " + 
                   (result.success ? "Success" : "Error") + 
                   (result.fromCache ? " (cached)" : ""));
                
                // Add to results
                results[parallelEndpoints[i]] = {
                    "data": result.data,
                    "fromCache": result.fromCache,
                    "timestamp": result.timestamp
                };
            });
            
            // Save all results to file
            œÉjsonResults = ‚éã.stringify(results, null, 2);
            ‚úç("api_results.json", jsonResults);
            ‚åΩ("\nResults saved to api_results.json");
            
            // Display cache statistics
            ŒæcacheStats = client.getCacheStats();
            
            ‚åΩ("\nCache Statistics:");
            ‚åΩ("  Total Requests: " + üî§(cacheStats.totalRequests));
            ‚åΩ("  Cache Hits: " + üî§(cacheStats.hits));
            ‚åΩ("  Cache Misses: " + üî§(cacheStats.misses));
            ‚åΩ("  Hit Ratio: " + üî§((cacheStats.hits / cacheStats.totalRequests * 100).toFixed(1)) + "%");
            ‚åΩ("  Cache Size: " + üî§(cacheStats.size) + " entries");
            
            ‚üº(‚ä§);
        }{
            ‚åΩ("Error in API client: " + ‚ö†.message);
            ‚üº(‚ä•);
        }
    }
    
    // Create an API client with caching and rate limiting
    ∆ícreateApiClient(œÉbaseUrl, ŒπrateLimit, œÉcacheDir, ŒπcacheExpiry){
        // Initialize state
        ŒærequestTimes = ‚àÖ;
        ŒæcacheStats = {
            "totalRequests": 0,
            "hits": 0,
            "misses": 0,
            "size": 0
        };
        
        // Helper function to enforce rate limiting
        ∆íenforceRateLimit(){
            Œπnow = Date.now();
            
            // Remove old requests from the tracking array
            ŒænewRequestTimes = ‚àÖ;
            ‚àÄ(requestTimes, œÜ(time){
                Œπ(now - time < 1000){  // Keep requests from the last second
                    Ôºã(newRequestTimes, time);
                }
            });
            
            requestTimes = newRequestTimes;
            
            // Check if we're over the rate limit
            Œπ(requestTimes.length >= rateLimit){
                // Calculate time to wait
                ŒπoldestTime = requestTimes[0];
                ŒπtimeToWait = 1000 - (now - oldestTime);
                
                Œπ(timeToWait > 0){
                    ‚åΩ("Rate limit reached. Waiting " + üî§(timeToWait) + "ms...");
                    ‚è∞(timeToWait);
                }
            }
            
            // Add current request time
            Ôºã(requestTimes, Date.now());
        }
        
        // Helper function to get cache key for an endpoint
        ∆ígetCacheKey(œÉendpoint){
            ‚üº(endpoint.replace(/[^a-zA-Z0-9]/g, "_"));
        }
        
        // Helper function to check if cache is valid
        ∆íisCacheValid(œÉcachePath){
            Œπ(!?(cachePath)){
                ‚üº(‚ä•);
            }
            
            // Get file modification time
            ŒæfileInfo = !("stat " + cachePath);
            Œπ(fileInfo.c !== 0){
                ‚üº(‚ä•);
            }
            
            // Parse the file info to get modification time
            œÉstatOutput = fileInfo.o;
            ŒæmatchResult = statOutput.match(/Modify: ([0-9]+)/);
            Œπ(!matchResult){
                ‚üº(‚ä•);
            }
            
            ŒπmodTime = üî¢(matchResult[1]);
            Œπnow = Math.floor(Date.now() / 1000);
            
            // Check if cache is expired
            ‚üº(now - modTime < cacheExpiry);
        }
        
        // Helper function to read from cache
        ∆íreadFromCache(œÉendpoint){
            œÉcacheKey = getCacheKey(endpoint);
            œÉcachePath = cacheDir + "/" + cacheKey + ".json";
            
            Œπ(isCacheValid(cachePath)){
                √∑{
                    œÉcacheContent = üìñ(cachePath);
                    ŒæcacheData = ‚éã.parse(cacheContent);
                    cacheStats.hits++;
                    ‚üº({
                        "success": ‚ä§,
                        "data": cacheData,
                        "fromCache": ‚ä§,
                        "timestamp": Date.now()
                    });
                }{
                    // If there's an error reading/parsing cache, treat as miss
                    cacheStats.misses++;
                    ‚üº(null);
                }
            }
            
            cacheStats.misses++;
            ‚üº(null);
        }
        
        // Helper function to write to cache
        ∆íwriteToCache(œÉendpoint, Œædata){
            œÉcacheKey = getCacheKey(endpoint);
            œÉcachePath = cacheDir + "/" + cacheKey + ".json";
            
            √∑{
                œÉcacheContent = ‚éã.stringify(data);
                ‚úç(cachePath, cacheContent);
                
                // Update cache size
                ŒæcacheFiles = !("ls -1 " + cacheDir + " | wc -l");
                Œπ(cacheFiles.c === 0){
                    cacheStats.size = üî¢(cacheFiles.o.trim());
                }
            }{
                // Ignore cache write errors
            }
        }
        
        // Main GET function
        ∆íget(œÉendpoint){
            cacheStats.totalRequests++;
            
            // Check cache first
            ŒæcachedResponse = readFromCache(endpoint);
            Œπ(cachedResponse){
                ‚üº(cachedResponse);
            }
            
            // Enforce rate limiting
            enforceRateLimit();
            
            // Make the actual API request
            √∑{
                œÉfullUrl = baseUrl + endpoint;
                Œæresponse = ‚Üó(fullUrl);
                
                Œπ(response.s‚â†200){
                    ‚üº({
                        "success": ‚ä•,
                        "error": "HTTP Error: " + response.s,
                        "fromCache": ‚ä•,
                        "timestamp": Date.now()
                    });
                }
                
                // Parse JSON response
                Œædata = ‚éã.parse(response.b);
                
                // Cache the response
                writeToCahe(endpoint, data);
                
                ‚üº({
                    "success": ‚ä§,
                    "data": data,
                    "fromCache": ‚ä•,
                    "timestamp": Date.now()
                });
            }{
                ‚üº({
                    "success": ‚ä•,
                    "error": "Request failed: " + ‚ö†.message,
                    "fromCache": ‚ä•,
                    "timestamp": Date.now()
                });
            }
        }
        
        // Function to make parallel requests
        ∆ígetParallel(Œæendpoints){
            Œæresults = ‚àÖ;
            
            // Process each endpoint
            ‚àÄ(endpoints, œÜ(endpoint){
                Œæresponse = get(endpoint);
                Ôºã(results, response);
            });
            
            ‚üº(results);
        }
        
        // Return the client object
        ‚üº({
            "get": get,
            "getParallel": getParallel,
            "getCacheStats": œÜ(){ ‚üº(cacheStats); }
        });
    }
}
